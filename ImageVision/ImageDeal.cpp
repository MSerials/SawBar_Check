// ImageDeal.cpp : 实现文件
//

#include "stdafx.h"
#include "ImageVision.h"
#include "ImageDeal.h"
#include <string.h>

// CImageDeal

CImageDeal::CImageDeal()
{
	set_system("do_low_error", "false");
}

CImageDeal::~CImageDeal()
{
	set_check("~give_error");
	clear_shape_model(TopShapeModelID);
	clear_variation_model(TopVariationModelID);
	clear_shape_model(BottomShapeModelID);
	clear_variation_model(BottomVariationModelID);
	set_check("give_error");
}


// CImageDeal 成员函数
#ifdef _HALCON


///////////////////////////////////////////////////////////////////////////////
//  File generated by HDevelop for HALCON/C++ Version 10.0
///////////////////////////////////////////////////////////////////////////////



#include "HalconCpp.h"




bool CImageDeal::Front_Train(const std::vector<std::string>& imgpath, const HTuple& WinHandle, const _Params &params)
{
	double  threshold = static_cast<double>(params.threshold_get_prod);
	std::vector<std::string> can_be_used_path; can_be_used_path.empty();
	HException::InstallHHandler(&CPPExpDefaultExceptionHandler);

	for (size_t i = 0; i < imgpath.size(); i++)
	{
		set_check("give_error");
		try{
			//TopROI_0 = ROI[0];
			Halcon::read_image(&TopoImage, imgpath[i].c_str());
			can_be_used_path.push_back(imgpath[i]);
		}
		catch (HException &HDevExpDefaultException)
		{
			set_check("~give_error");
			continue;
		}
	}
	if (0 == can_be_used_path.size()) {
		AfxMessageBox(L"模板中没有任何可以读取的图片!"); return false;
	}
	set_check("give_error");
	try
	{
		Halcon::read_image(&TopoImage, can_be_used_path[0].c_str());
		Halcon::bit_not(TopoImage, &TopbImage);
		Halcon::gen_rectangle1(&TopROI_0, params.ROI_row1, params.ROI_col1, params.ROI_row2, params.ROI_col2);
		Halcon::reduce_domain(TopbImage, TopROI_0, &TopImage);
		Halcon::get_image_size(TopImage, &TopWidth, &TopHeight);
		Halcon::threshold(TopImage, &TopRegion, threshold, 255);
		Halcon::fill_up(TopRegion, &TopRegionFillUp);
		Halcon::difference(TopRegionFillUp, TopRegion, &TopRegionDifference);
		//找到骨架
		Halcon::shape_trans(TopRegionDifference, &TopRegionTrans, "convex");
		//字符范围
		Halcon::dilation_circle(TopRegionTrans, &TopRegionDilation, 8.5);
		Halcon::reduce_domain(TopImage, TopRegionDilation, &TopImageReduced);
		Halcon::inspect_shape_model(TopImageReduced, &TopModelImages, &TopModelRegions, 1, 20);
		Halcon::gen_contours_skeleton_xld(TopModelRegions, &TopModel, 1, "filter");
		Halcon::area_center(TopRegionDilation, &TopArea, &TopRowRef, &TopColumnRef);
		Halcon::create_shape_model(TopImageReduced, 5, HTuple(-10).Rad(), HTuple(20).Rad(), "auto", "none", "use_polarity", 20, 10, &TopShapeModelID);
		Halcon::create_variation_model(TopWidth, TopHeight, "byte", "standard", &TopVariationModelID);

		clear_window(WinHandle);
		//循环读取模板图片
		for (size_t i = 0; i < can_be_used_path.size(); i++)
		{
			Halcon::read_image(&TopoImage, can_be_used_path[i].c_str());
			Halcon::bit_not(TopoImage, &TopbImage);
			Halcon::reduce_domain(TopbImage, TopROI_0, &TopImage);
			Halcon::disp_obj(TopImage,WinHandle);
			Halcon::find_shape_model(TopImage, TopShapeModelID, HTuple(-30).Rad(), HTuple(60).Rad(), 0.5,
				1, 0.5, "least_squares", 0, 0.9, &TopRow, &TopColumn, &TopAngle, &TopScore);

			if (0 != ((TopScore.Num()) > params.TrainScore))
			{
				Halcon::vector_angle_to_rigid(TopRow, TopColumn, TopAngle, TopRowRef, TopColumnRef, 0, &TopHomMat2D);
				Halcon::affine_trans_image(TopImage, &TopImageTrans, TopHomMat2D, "constant", "false");
				Halcon::train_variation_model(TopImageTrans, TopVariationModelID);
			}
		}
		Halcon::get_variation_model(&TopMeanImage, &TopVarImage, TopVariationModelID);
		Halcon::prepare_variation_model(TopVariationModelID, 20, 3);
		//We can now free the training data to save some memory.
		Halcon::clear_train_data_variation_model(TopVariationModelID);
		erosion_rectangle1(TopRegionFillUp, &TopRegionROI, 1, 15);
	}
	catch (HException &HDevExpDefaultException)
	{
		set_check("~give_error");
		return false;
	}
	return true;
}



int CImageDeal::Front_Deal(const Hobject src, const HTuple& WinHandle, const _Params &params)//image roi,result
{

	//res = -1 is error
	//res = 0 is NG
	//res = 1 is OK
	HException::InstallHHandler(&CPPExpDefaultExceptionHandler);
	try{
		Halcon::set_check("give_error");
		Halcon::gen_rectangle1(&TopROI_0, params.ROI_row1, params.ROI_col1, params.ROI_row2, params.ROI_col2);
		Halcon::bit_not(src, &TopbImage);
		Halcon::reduce_domain(TopbImage, TopROI_0, &TopImage);
		Halcon::find_shape_model(TopImage, TopShapeModelID, HTuple(-10).Rad(), HTuple(20).Rad(), 0.5,
			1, 0.5, "least_squares", 0, 0.9, &TopRow, &TopColumn, &TopAngle, &TopScore);
		if (0 != ((TopScore.Num()) > params.MatchScore))
		{
			Halcon::vector_angle_to_rigid(TopRow, TopColumn, TopAngle, TopRowRef, TopColumnRef, 0, &TopHomMat2D);
			Halcon::affine_trans_image(TopImage, &TopImageTrans, TopHomMat2D, "constant", "false");
			Halcon::reduce_domain(TopImageTrans, TopRegionROI, &TopImageReduced);
			Halcon::compare_variation_model(TopImageReduced, &TopRegionDiff, TopVariationModelID);
			Halcon::connection(TopRegionDiff, &TopConnectedRegions);
			Halcon::select_shape(TopConnectedRegions, &TopRegionsError, "area", "and", 20, 1000000);
			Halcon::count_obj(TopRegionsError, &TopNumError);

			//quxiao
			Halcon::clear_window(WinHandle);
			Halcon::disp_obj(TopImageTrans, WinHandle);
			Halcon::set_color(WinHandle, "red");
			Halcon::disp_obj(TopRegionsError, WinHandle);
			Halcon::set_tposition(WinHandle, 20, 20);
			if (0 != (TopNumError == 0))
			{
				Halcon::set_color(WinHandle, "green");
				Halcon::write_string(WinHandle, "Product is OK");
				return 1;
			}
			else
			{
				Halcon::set_color(WinHandle, "red");
				Halcon::write_string(WinHandle, "Product is NG");
				return 0;
			}
		}
		else
		{
			Halcon::set_tposition(WinHandle, 20, 20);
			Halcon::set_color(WinHandle, "red");
			Halcon::write_string(WinHandle, "检测物体不匹配样品");
			return -1;
		}
	}
	catch (HException &HDevExpDefaultException)
	{
		set_check("~give_error");
		return -1;
	}
		
}








bool CImageDeal::Back_Train(const std::vector<std::string>& imgpath, const HTuple& WinHandle, const _Params &params)
{
	double  threshold = static_cast<double>(params.threshold_get_prod);
	std::vector<std::string> can_be_used_path; can_be_used_path.empty();
	HException::InstallHHandler(&CPPExpDefaultExceptionHandler);

	for (size_t i = 0; i < imgpath.size(); i++)
	{
		set_check("give_error");
		try{
			//BottomROI_0 = ROI[0];
			Halcon::read_image(&BottomoImage, imgpath[i].c_str());
			can_be_used_path.push_back(imgpath[i]);
		}
		catch (HException &HDevExpDefaultException)
		{
			set_check("~give_error");
			continue;
		}
	}
	if (0 == can_be_used_path.size()) {
		AfxMessageBox(L"模板中没有任何可以读取的图片!"); return false;
	}
	set_check("give_error");
	try
	{
		Halcon::read_image(&BottomoImage, can_be_used_path[0].c_str());
		Halcon::bit_not(BottomoImage, &BottombImage);
		Halcon::gen_rectangle1(&BottomROI_0, params.ROI_row1, params.ROI_col1, params.ROI_row2, params.ROI_col2);
		Halcon::reduce_domain(BottombImage, BottomROI_0, &BottomImage);
		Halcon::get_image_size(BottomImage, &BottomWidth, &BottomHeight);
		Halcon::threshold(BottomImage, &BottomRegion, threshold, 255);
		Halcon::fill_up(BottomRegion, &BottomRegionFillUp);
		Halcon::difference(BottomRegionFillUp, BottomRegion, &BottomRegionDifference);
		//找到骨架
		Halcon::shape_trans(BottomRegionDifference, &BottomRegionTrans, "convex");
		//字符范围
		Halcon::dilation_circle(BottomRegionTrans, &BottomRegionDilation, 8.5);
		Halcon::reduce_domain(BottomImage, BottomRegionDilation, &BottomImageReduced);
		Halcon::inspect_shape_model(BottomImageReduced, &BottomModelImages, &BottomModelRegions, 1, 20);
		Halcon::gen_contours_skeleton_xld(BottomModelRegions, &BottomModel, 1, "filter");
		Halcon::area_center(BottomRegionDilation, &BottomArea, &BottomRowRef, &BottomColumnRef);
		Halcon::create_shape_model(BottomImageReduced, 5, HTuple(-10).Rad(), HTuple(20).Rad(), "auto", "none", "use_polarity", 20, 10, &BottomShapeModelID);
		Halcon::create_variation_model(BottomWidth, BottomHeight, "byte", "standard", &BottomVariationModelID);

		clear_window(WinHandle);
		//循环读取模板图片
		for (size_t i = 0; i < can_be_used_path.size(); i++)
		{
			Halcon::read_image(&BottomoImage, can_be_used_path[i].c_str());
			Halcon::bit_not(BottomoImage, &BottombImage);
			Halcon::reduce_domain(BottombImage, BottomROI_0, &BottomImage);
			Halcon::disp_obj(BottomImage, WinHandle);
			Halcon::find_shape_model(BottomImage, BottomShapeModelID, HTuple(-30).Rad(), HTuple(60).Rad(), 0.5,
				1, 0.5, "least_squares", 0, 0.9, &BottomRow, &BottomColumn, &BottomAngle, &BottomScore);

			if (0 != ((BottomScore.Num()) > params.TrainScore))
			{
				Halcon::vector_angle_to_rigid(BottomRow, BottomColumn, BottomAngle, BottomRowRef, BottomColumnRef, 0, &BottomHomMat2D);
				Halcon::affine_trans_image(BottomImage, &BottomImageTrans, BottomHomMat2D, "constant", "false");
				Halcon::train_variation_model(BottomImageTrans, BottomVariationModelID);
			}
		}
		Halcon::get_variation_model(&BottomMeanImage, &BottomVarImage, BottomVariationModelID);
		Halcon::prepare_variation_model(BottomVariationModelID, 20, 3);
		//We can now free the training data to save some memory.
		Halcon::clear_train_data_variation_model(BottomVariationModelID);
		erosion_rectangle1(BottomRegionFillUp, &BottomRegionROI, 1, 15);
	}
	catch (HException &HDevExpDefaultException)
	{
		set_check("~give_error");
		return false;
	}
	return true;
}

int CImageDeal::Back_Deal(const Hobject src, const HTuple& WinHandle, const _Params &params)//image roi,result
{
	HException::InstallHHandler(&CPPExpDefaultExceptionHandler);
	try
	{
		Halcon::set_check("give_error");
		Halcon::gen_rectangle1(&BottomROI_0, params.ROI_row1, params.ROI_col1, params.ROI_row2, params.ROI_col2);
		Halcon::bit_not(src, &BottombImage);
		Halcon::reduce_domain(BottombImage, BottomROI_0, &BottomImage);
		Halcon::find_shape_model(BottomImage, BottomShapeModelID, HTuple(-10).Rad(), HTuple(20).Rad(), 0.5,
			1, 0.5, "least_squares", 0, 0.9, &BottomRow, &BottomColumn, &BottomAngle, &BottomScore);
		if (0 != ((BottomScore.Num()) > params.MatchScore))
		{
			Halcon::vector_angle_to_rigid(BottomRow, BottomColumn, BottomAngle, BottomRowRef, BottomColumnRef, 0, &BottomHomMat2D);
			Halcon::affine_trans_image(BottomImage, &BottomImageTrans, BottomHomMat2D, "constant", "false");
			Halcon::reduce_domain(BottomImageTrans, BottomRegionROI, &BottomImageReduced);
			Halcon::compare_variation_model(BottomImageReduced, &BottomRegionDiff, BottomVariationModelID);
			Halcon::connection(BottomRegionDiff, &BottomConnectedRegions);
			Halcon::select_shape(BottomConnectedRegions, &BottomRegionsError, "area", "and", 20, 1000000);
			Halcon::count_obj(BottomRegionsError, &BottomNumError);

			//quxiao
			Halcon::clear_window(WinHandle);
			Halcon::disp_obj(TopImageTrans, WinHandle);
			Halcon::set_color(WinHandle, "red");
			Halcon::disp_obj(TopRegionsError, WinHandle);
			Halcon::set_tposition(WinHandle, 20, 20);
			if (0 != (TopNumError == 0))
			{
				Halcon::set_color(WinHandle, "green");
				Halcon::write_string(WinHandle, "Product is OK");
				return 1;
			}
			else
			{
				Halcon::set_color(WinHandle, "red");
				Halcon::write_string(WinHandle, "Product is NG");
				return 0;
			}
		}
		else
		{
			Halcon::set_tposition(WinHandle, 20, 20);
			Halcon::set_color(WinHandle, "red");
			Halcon::write_string(WinHandle, "检测物体不匹配样品");
			return -1;
		}
	}
	catch (HException &HDevExpDefaultException)
	{
		set_check("~give_error");
		return -1;
	}
}

























#endif